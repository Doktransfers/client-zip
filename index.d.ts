type BufferLike = ArrayBuffer | string | ArrayBufferView | Blob
type StreamLike = ReadableStream<Uint8Array> | AsyncIterable<BufferLike>

/** The file name, modification date and size will be read from the input;
 * extra arguments can be given to override the input’s metadata. */
 type InputWithMeta = File | Response | { input: File | Response, name?: any, lastModified?: any, size?: number | bigint, mode?: number }

 /** Intrinsic size, but the file name must be provided and modification date can’t be guessed. */
 type InputWithSizeMeta = { input: BufferLike, name: any, lastModified?: any, size?: number | bigint, mode?: number }
 
 /** The file name must be provided ; modification date and content length can’t be guessed. */
 type InputWithoutMeta = { input: StreamLike, name: any, lastModified?: any, size?: number | bigint, mode?: number }
 
/** The folder name must be provided ; modification date can’t be guessed. */
type InputFolder = { name: any, lastModified?: any, input?: never, size?: never, mode?: number }

 /** Both filename and size must be provided ; input is not helpful here. */
 type JustMeta = { input?: StreamLike | undefined, name: any, lastModified?: any, size: number | bigint, mode?: number }
 
 type ForAwaitable<T> = AsyncIterable<T> | Iterable<T>

/** Enhanced ReadableStream interface with size property */
interface ReadableStreamWithSize<T> extends ReadableStream<T> {
  readonly size?: bigint
}

/** Metadata for ZIP entries */
interface ZipEntryMetadata {
  filename: string
  offset: bigint
  dataOffset: bigint
  compressedSize: bigint
  uncompressedSize: bigint
  crc32: number
  compressionMethod: number
  flags: number
  headerSize: number
}
 
 type Options = {
 /** If provided, the returned Response will have its `Content-Length` header set to this value.
 * It can be computed accurately with the `predictLength` function. */
 length?: number | bigint
 /** If provided, the returned Response will have its `Content-Length` header set to the result of
 * calling `predictLength` on that metadata. Overrides the `length` option. */
 metadata?: Iterable<InputWithMeta | InputWithSizeMeta | JustMeta>
 /** The ZIP *language encoding flag* will always be set when a filename was given as a string,
  * but when it is given as an ArrayView or ArrayBuffer, it depends on this option :
  * - `true`: always on (ArrayBuffers will *always* be flagged as UTF-8) — recommended,
  * - `false`: always off (ArrayBuffers will *never* be flagged as UTF-8),
  * - `undefined`: each ArrayBuffer will be tested and flagged if it is valid UTF-8. */
 buffersAreUTF8?: boolean
 /** Callback that receives metadata for each ZIP entry as it's processed.
  * Useful for getting entry offsets, data offsets, CRC32 values, etc. */
 onEntry?: (entry: ZipEntryMetadata) => void
 /** AbortSignal to cancel the ZIP generation process.
  * When aborted, the ZIP generation will stop and throw an AbortError. */
 signal?: AbortSignal
} 

/** Given an iterable of file metadata (or equivalent),
 * @returns the exact byte length of the Zip file that would be generated by `downloadZip`. */
export declare function predictLength(files: Iterable<InputWithMeta | InputWithSizeMeta | JustMeta | InputFolder>): bigint

export declare function downloadZip(files: ForAwaitable<InputWithMeta | InputWithSizeMeta | InputWithoutMeta | InputFolder>, options?: Options): Response

export declare function downloadZipWithEntries(files: ForAwaitable<InputWithMeta | InputWithSizeMeta | InputWithoutMeta | InputFolder>, options?: Options): { response: Response, entries: Promise<ZipEntryMetadata[]> }

export declare function makeZip(files: ForAwaitable<InputWithMeta | InputWithSizeMeta | InputWithoutMeta | InputFolder>, options?: Options): ReadableStreamWithSize<Uint8Array>

export declare function makeZipWithEntries(files: ForAwaitable<InputWithMeta | InputWithSizeMeta | InputWithoutMeta | InputFolder>, options?: Options): { stream: ReadableStreamWithSize<Uint8Array>, entries: Promise<ZipEntryMetadata[]> }

export { ZipEntryMetadata, ReadableStreamWithSize }